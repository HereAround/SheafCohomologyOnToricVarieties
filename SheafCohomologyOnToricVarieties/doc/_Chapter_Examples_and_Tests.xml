<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Examples_and_Tests">
<Heading>Examples and Tests</Heading>

<Section Label="Chapter_Examples_and_Tests_Section_Cone_and_semigroup_wrappers">
<Heading>Cone and semigroup wrappers</Heading>

The following commands are used to handle generators of semigroups in <Math>\mathbb{Z}^n</Math>, generators of cones in <Math>\mathbb{Z}^n</Math>
as well as hyperplane constraints that define cones in <Math>\mathbb{Z}^n</Math>. Here are some examples:
<Example><![CDATA[
gap> semigroup1 := SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 1,1 ]] );
<A cone-semigroup in Z^2 formed as the span of 2 generators>
gap> IsSemigroupForPresentationsByProjectiveGradedModules( semigroup1 );
true
gap> GeneratorList( semigroup1 );
[ [ 1, 0 ], [ 1, 1 ] ]
gap> semigroup2 := SemigroupForPresentationsByProjectiveGradedModules( [[ 2,0 ], [ 1,1 ]] );
<A non-cone semigroup in Z^2 formed as the span of 2 generators>
gap> IsSemigroupForPresentationsByProjectiveGradedModules( semigroup2 );
true
gap> GeneratorList( semigroup2 );
[ [ 2, 0 ], [ 1, 1 ] ]
]]></Example>


We can check if a semigroup in <Math>\mathbb{Z}^n</Math> is the semigroup of a cone. In case we can look at an H-presentation
of this cone.
<Example><![CDATA[
gap> IsSemigroupOfCone( semigroup1 );
true
gap> ConeHPresentationList( semigroup1 );
[ [ 0, 1 ], [ 1, -1 ] ]
gap> Display( ConeHPresentationList( semigroup1 ) );
[ [   0,  1 ],
  [   1, -1 ] ]
gap> IsSemigroupOfCone( semigroup2 );
false
gap> HasConeHPresentationList( semigroup2 );
false
]]></Example>


We can check membership of points in semigroups.
<Example><![CDATA[
gap> PointContainedInSemigroup( semigroup2, [ 1,0 ] );
false
gap> PointContainedInSemigroup( semigroup2, [ 2,0 ] );
true
]]></Example>


Given a semigroup <Math>S \subseteq \mathbb{Z}^n</Math> and a point <Math>p \in \mathbb{Z}^n</Math> we can consider
<Display> H := p + S = \left\{ p + x \; , \; x \in S \right\}. </Display>
We term this an affine semigroup. Given that <Math>S = C \cap \mathbb{Z}^n</Math> for a cone <Math>C \subseteq \mathbb{Z}^n</Math>, we use
the term affine cone_semigroup. The constructors are as follows:
<Example><![CDATA[
gap> affine_semigroup1 := AffineSemigroupForPresentationsByProjectiveGradedModules( semigroup1, [ -1, -1 ] );
<A non-trivial affine cone-semigroup in Z^2>
gap> affine_semigroup2 := AffineSemigroupForPresentationsByProjectiveGradedModules( semigroup2, [ 2, 2 ] );
<A non-trivial affine non-cone semigroup in Z^2>
]]></Example>


We can access the properties of these affine semigroups as follows.
<Example><![CDATA[
gap> IsAffineSemigroupOfCone( affine_semigroup2 );
false
gap> UnderlyingSemigroup( affine_semigroup2 );
<A non-cone semigroup in Z^2 formed as the span of 2 generators>
gap> Display( UnderlyingSemigroup( affine_semigroup2 ) );
A non-cone semigroup in Z^2 formed as the span of 2 generators - generators are as follows:
[ [  2,  0 ],
  [  1,  1 ] ]
gap> IsAffineSemigroupOfCone( affine_semigroup1 );
true
gap> Offset( affine_semigroup2 );
[ 2, 2 ]
gap> ConeHPresentationList( UnderlyingSemigroup( affine_semigroup1 ) );
[ [ 0, 1 ], [ 1, -1 ] ]
]]></Example>


Of course we can also decide membership in affine (cone_)semigroups.
<Example><![CDATA[
gap> Display( affine_semigroup1 );
A non-trivial affine cone-semigroup in Z^2
Offset: [ -1, -1 ]
Hilbert basis: [ [ 1, 0 ], [ 1, 1 ] ]
gap> PointContainedInAffineSemigroup( affine_semigroup1, [ -2,-2 ] );
false
gap> PointContainedInAffineSemigroup( affine_semigroup1, [ 3,1 ] );
true
gap> Display( affine_semigroup2 );
A non-trivial affine non-cone semigroup in Z^2
Offset: [ 2, 2 ]
Semigroup generators: [ [ 2, 0 ], [ 1, 1 ] ]
gap> PointContainedInAffineSemigroup( affine_semigroup2, [ 3,2 ] );
false
gap> PointContainedInAffineSemigroup( affine_semigroup2, [ 3,3 ] );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Truncations_of_projective_graded_left_modules">
<Heading>Truncations of projective graded left modules</Heading>

<Example><![CDATA[
gap> Q := HomalgFieldOfRationalsInSingular();
Q
gap> S := GradedRing( Q * "x_1, x_2, x_3, x_4" );
Q[x_1,x_2,x_3,x_4]
(weights: yet unset)
gap> SetWeightsOfIndeterminates( S, [[1,0],[1,0],[0,1],[0,1]] );

gap> D := DegreeGroup( S );
<A free left module of rank 2 on free generators>
gap> IsFree( D );
true
gap> NewObjectL := CAPCategoryOfProjectiveGradedLeftModulesObject( 
>               [ [[1,0],1], [[-1,-1],2] ], S );
<A projective graded left module of rank 3>
gap> tL := TruncationOfProjectiveGradedModule( NewObjectL, 
>       SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,1]] ) );
<A projective graded left module of rank 1>
gap> Display( tL );
A projective graded left module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: [ [ ( 1, 0 ), 1 ] ]
gap> tL2 := TruncationOfProjectiveGradedModule( NewObjectL, 
>        SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,2 ]] ) );
<A projective graded left module of rank 1>
gap> Display( tL2 );
A projective graded left module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: [ [ ( 1, 0 ), 1 ] ]
gap> embL := EmbeddingOfTruncationOfProjectiveGradedModule( NewObjectL, 
>         SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,1]] ) );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( embL ) );
1, 0, 0
(over a graded ring)
gap> embL2 := EmbeddingOfTruncationOfProjectiveGradedModule( NewObjectL, 
>         SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,2]] ) );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( embL2 ) );
1, 0, 0
(over a graded ring)
gap> embL3 := EmbeddingOfTruncationOfProjectiveGradedModuleWithGivenTruncationObject(
>          NewObjectL, tL );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( embL3 ) );
1, 0, 0
(over a graded ring)
gap> projL := ProjectionOntoTruncationOfProjectiveGradedModule( NewObjectL, 
>          SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,1 ]] ) );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( projL ) );
1,
0,
0
(over a graded ring)
gap> projL2 := ProjectionOntoTruncationOfProjectiveGradedModule( NewObjectL, 
>          SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,2 ]] ) );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( projL2 ) );
1,
0,
0 
(over a graded ring)
gap> projL3 := ProjectionOntoTruncationOfProjectiveGradedModuleWithGivenTruncationObject( 
>           NewObjectL, tL ); 
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( projL3 ) );
1,
0,
0 
(over a graded ring)
gap> truncatorL := TruncationFunctorForProjectiveGradedLeftModules(
>                         S, SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,2 ]] ) );
Truncation functor for CAP category of projective graded 
left modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
to the semigroup generated by [ [ 1, 0 ], [ 0, 2 ] ]
gap> truncatorL2 := TruncationFunctorForProjectiveGradedLeftModules(
>                         S, SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,1 ]] ) );
Truncation functor for CAP category of projective graded 
left modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
to the semigroup generated by [ [ 1,0 ], [ 0, 1 ] ]
gap> tL2 := ApplyFunctor( truncatorL, NewObjectL );
<A projective graded left module of rank 1>
gap> Display( tL2 );
A projective graded left module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: [ [ ( 1, 0 ), 1 ] ]
gap> sourceL := CAPCategoryOfProjectiveGradedLeftModulesObject( 
>            [ [[1,0],1], [[0,1],1] ], S );
<A projective graded left module of rank 2>
gap> rangeL := CAPCategoryOfProjectiveGradedLeftModulesObject( 
>            [ [[1,0],1] ], S );
<A projective graded left module of rank 1>
gap> test_morphismL := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       sourceL, HomalgMatrix( [ [ 1 ],[ 0 ] ], S ) ,rangeL );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> tr_test_morphismL := ApplyFunctor( truncatorL, test_morphismL );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( tr_test_morphismL ) );
1
(over a graded ring)
gap> tr2_test_morphismL := ApplyFunctor( truncatorL2, test_morphismL );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( tr2_test_morphismL ) );
1,
0
(over a graded ring)
gap> nat_trans_l := NaturalTransformationFromTruncationToIdentityForProjectiveGradedLeftModules( 
>                         S, SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,1 ]] ) );
Natural transformation from Truncation functor for CAP category 
of projective graded left modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
to the semigroup generated by [ [ 1, 0 ], [ 0, 1 ] ] to id
gap> component_l := ApplyNaturalTransformation( nat_trans_l, NewObjectL );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( component_l ) );
1, 0, 0
(over a graded ring)
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Truncations_of_projective_graded_right_modules">
<Heading>Truncations of projective graded right modules</Heading>

<Example><![CDATA[
gap> NewObjectR := CAPCategoryOfProjectiveGradedRightModulesObject( 
>               [ [[1,0],1], [[-1,-1],2] ], S );
<A projective graded right module of rank 3>
gap> tR := TruncationOfProjectiveGradedModule( NewObjectR, 
>       SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,1]] ) );
<A projective graded right module of rank 1>
gap> Display( tR );
A projective graded right module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: [ [ ( 1, 0 ), 1 ] ]
gap> tR2 := TruncationOfProjectiveGradedModule( NewObjectR, 
>        SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,2 ]] ) );
<A projective graded right module of rank 1>
gap> Display( tR2 );
A projective graded right module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: [ [ ( 1, 0 ), 1 ] ]
gap> embR := EmbeddingOfTruncationOfProjectiveGradedModule( NewObjectR, 
>         SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,1]] ) );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( embR ) );
1,
0,
0
(over a graded ring)
gap> embR2 := EmbeddingOfTruncationOfProjectiveGradedModule( NewObjectL, 
>         SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,2]] ) );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( embR2 ) );
1,
0,
0
(over a graded ring)
gap> embR3 := EmbeddingOfTruncationOfProjectiveGradedModuleWithGivenTruncationObject(
>          NewObjectR, tR );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( embR3 ) );
1,
0,
0
(over a graded ring)
gap> projR := ProjectionOntoTruncationOfProjectiveGradedModule( NewObjectR,
>          SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,1 ]] ) );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( projR ) );
1, 0, 0
(over a graded ring)
gap> projR2 := ProjectionOntoTruncationOfProjectiveGradedModule( NewObjectR, 
>          SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,2 ]] ) );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( projR2 ) );
1, 0, 0
(over a graded ring)
gap> projR3 := ProjectionOntoTruncationOfProjectiveGradedModuleWithGivenTruncationObject( 
>           NewObjectR, tR ); 
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( projR3 ) );
1, 0, 0
(over a graded ring)
gap> truncatorR := TruncationFunctorForProjectiveGradedRightModules( S, 
>                              SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,2 ]] ) );
Truncation functor for CAP category of projective graded 
right modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
to the semigroup generated by [ [ 1, 0 ], [ 0, 2 ] ]
gap> truncatorR2 := TruncationFunctorForProjectiveGradedRightModules(
>                         S, SemigroupForPresentationsByProjectiveGradedModules( [[ 1,0 ], [ 0,1 ]] ) );
Truncation functor for CAP category of projective graded 
right modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
to the semigroup generated by [ [ 1, 0 ], [ 0, 1 ] ]
gap> tR2 := ApplyFunctor( truncatorR, NewObjectR );
<A projective graded right module of rank 1>
gap> Display( tR2 );
A projective graded right module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: [ [ ( 1, 0 ), 1 ] ]
gap> sourceR := CAPCategoryOfProjectiveGradedRightModulesObject( 
>            [ [[1,0],1], [[0,1],1] ], S );
<A projective graded right module of rank 2>
gap> rangeR := CAPCategoryOfProjectiveGradedRightModulesObject( 
>            [ [[1,0],1] ], S );
<A projective graded right module of rank 1>
gap> test_morphismR := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       sourceR, HomalgMatrix( [ [ 1, 0 ] ], S ) ,rangeR );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> tr_test_morphismR := ApplyFunctor( truncatorR, test_morphismR );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( tr_test_morphismR ) );
1
(over a graded ring)
gap> tr2_test_morphismR := ApplyFunctor( truncatorR2, test_morphismR );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( tr2_test_morphismR ) );
1, 0
(over a graded ring)
gap> nat_trans_r := NaturalTransformationFromTruncationToIdentityForProjectiveGradedRightModules
>                                ( S, SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,1]] ) );
Natural transformation from Truncation functor for CAP category 
of projective graded right modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
to the semigroup generated by [ [ 1,0 ], [ 0, 1 ] ] to id
gap> component_r := ApplyNaturalTransformation( nat_trans_r, NewObjectR );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> Display( UnderlyingHomalgMatrix( component_r ) );
1, 0, 0
(over a graded ring)
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Truncations_in_SfpgrmodLeft">
<Heading>Truncations in SfpgrmodLeft</Heading>

<Example><![CDATA[
gap> Q1 := CAPCategoryOfProjectiveGradedLeftModulesObject( [ [[2,0],1] ], S );
<A projective graded left module of rank 1>
gap> Q2 := CAPCategoryOfProjectiveGradedLeftModulesObject( [ [[1,0],1], [[-1,0],1] ], S );
<A projective graded left module of rank 2>
gap> Q3 := CAPCategoryOfProjectiveGradedLeftModulesObject( [ [[1,0],1] ], S );
<A projective graded left module of rank 1>
gap> Q4 := CAPCategoryOfProjectiveGradedLeftModulesObject( [ [[1,0],1] ], S );
<A projective graded left module of rank 1>
gap> m1l := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       Q1, HomalgMatrix( [["x_1","x_2^3"]], S ) ,Q2 );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> m2l := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       Q2, HomalgMatrix( [[1],[0]], S ) ,Q3 );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> m3l := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       Q4, HomalgMatrix( [[1]], S ) ,Q3 );
<A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> left_category := CapCategory( Q1 ); 
CAP category of projective graded left modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
gap> left_presentation1 := CAPPresentationCategoryObject( m1l );
<A graded left module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> left_presentation2 := CAPPresentationCategoryObject( m2l );
<A graded left module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> left_presentation3 := CAPPresentationCategoryObject( m3l );
<A graded left module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> truncation_functor_left := TruncationFunctorLeft( 
>                            S, SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,1]] ) );
Truncation functor for Category of graded left module presentations 
over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
to the semigroup generated by [ [ 1, 0 ], [ 0, 1 ] ]
gap> truncation1l := ApplyFunctor( truncation_functor_left, left_presentation1 );
<A graded left module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> FullInformation( truncation1l );
================================================================================= 

A projective graded left module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 2, 0 ), 1 ] ]

A morphism in the category of projective graded left modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) with matrix: 
x_1
(over a graded ring)

A projective graded left module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 1, 0 ), 1 ] ]

================================================================================= 
gap> truncation2l := ApplyFunctor( truncation_functor_left, left_presentation2 );
<A graded left module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> FullInformation( truncation2l );
================================================================================= 

A projective graded left module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and 
degrees: 
[ [ ( 1, 0 ), 1 ] ]

A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ]) 
with matrix:
1
(over a graded ring)

A projective graded left module over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 1, 0 ), 1 ] ]

================================================================================= 
gap> morl := CAPPresentationCategoryMorphism( left_presentation1, m2l, left_presentation3 );
<A morphism of graded left module presentations over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> trmorl := ApplyFunctor( truncation_functor_left, morl );
<A morphism of graded left module presentations over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> FullInformation( trmorl );

=================================================================================

Source:
------- 
A projective graded left module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 2, 0 ), 1 ] ]

A morphism in the category of projective graded left modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) with matrix: 
x_1
(over a graded ring)

A projective graded left module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 0 ), 1 ] ]

--------------------------------------------------------------------------------- 

Mapping matrix:
---------------
A morphism in the category of projective graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
with matrix: 
1
(over a graded ring)

--------------------------------------------------------------------------------- 

Range:
------
A projective graded left module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 0 ), 1 ] ]

A morphism in the category of projective graded left modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) with matrix: 
1
(over a graded ring)

A projective graded left module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 1, 0 ), 1 ] ]

================================================================================= 

]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Truncations_for_graded_module_presentations_for_CAP">
<Heading>Truncations for graded module presentations (for CAP)</Heading>

<Example><![CDATA[
gap> P1 := CAPCategoryOfProjectiveGradedRightModulesObject( [ [[2,0],1] ], S );
<A projective graded right module of rank 1>
gap> P2 := CAPCategoryOfProjectiveGradedRightModulesObject( [ [[1,0],1], [[-1,0],1] ], S );
<A projective graded right module of rank 2>
gap> P3 := CAPCategoryOfProjectiveGradedRightModulesObject( [ [[1,0],1] ], S );
<A projective graded right module of rank 1>
gap> P4 := CAPCategoryOfProjectiveGradedRightModulesObject( [ [[1,0],1] ], S );
<A projective graded right module of rank 1>
gap> m1r := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       P1, HomalgMatrix( [["x_1"],["x_2^3"]], S ) ,P2 );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> m2r := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       P2, HomalgMatrix( [[1,0]], S ) ,P3 );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> m3r := CAPCategoryOfProjectiveGradedLeftOrRightModulesMorphism( 
>       P4, HomalgMatrix( [[1]], S ) ,P3 );
<A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])>
gap> right_category := CapCategory( P1 ); 
CAP category of projective graded right modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
gap> right_presentation1 := CAPPresentationCategoryObject( m1r );
<A graded right module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> right_presentation2 := CAPPresentationCategoryObject( m2r );
<A graded right module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> right_presentation3 := CAPPresentationCategoryObject( m3r );
<A graded right module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> truncation_functor_right := TruncationFunctorRight( 
>                             S, SemigroupForPresentationsByProjectiveGradedModules( [[1,0],[0,1]] ) );
Truncation functor for Category of graded right module presentations 
over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
to the semigroup generated by [ [ 1, 0 ], [ 0, 1 ] ]
gap> truncation1r := ApplyFunctor( truncation_functor_right, right_presentation1 );
<A graded right module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> FullInformation( truncation1r );
================================================================================= 

A projective graded right module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 2, 0 ), 1 ] ]

A morphism in the category of projective graded right modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ]])
with matrix:
x_1
(over a graded ring)

A projective graded right module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 0 ), 1 ] ]

=================================================================================
gap> truncation2r := ApplyFunctor( truncation_functor_right, right_presentation2 );
<A graded right module presentation over the ring Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> FullInformation( truncation2r );
================================================================================= 

A projective graded right module over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and 
degrees: 
[ [ ( 1, 0 ), 1 ] ]

A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ]) 
with matrix:
1
(over a graded ring)

A projective graded right module over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 1, 0 ), 1 ] ]

=================================================================================
gap> morr := CAPPresentationCategoryMorphism( right_presentation1, m2r, right_presentation3 );
<A morphism of graded right module presentations over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> trmorr := ApplyFunctor( truncation_functor_right, morr );
<A morphism of graded right module presentations over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])>
gap> FullInformation( trmorr );

================================================================================= 

Source: 
------- 
A projective graded right module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 2, 0 ), 1 ] ]

A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
with matrix: 
x_1
(over a graded ring)

A projective graded right module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 1, 0 ), 1 ] ]

--------------------------------------------------------------------------------- 

Mapping matrix: 
--------------- 
A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
with matrix: 
1
(over a graded ring)

--------------------------------------------------------------------------------- 

Range: 
------ 
A projective graded right module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 1, 0 ), 1 ] ]

A morphism in the category of projective graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
with matrix: 
1
(over a graded ring)

A projective graded right module over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ ( 1, 0 ), 1 ] ]

================================================================================= 

]]></Example>


</Section>


</Chapter>

