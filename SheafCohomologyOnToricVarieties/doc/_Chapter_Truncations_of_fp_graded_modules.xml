<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Truncations_of_fp_graded_modules">
<Heading>Truncations of f.p. graded modules</Heading>

<Section Label="Chapter_Truncations_of_fp_graded_modules_Section_Truncations_of_fp_graded_modules">
<Heading>Truncations of fp graded modules</Heading>

<ManSection>
  <Oper Arg="V, M, d, B, F" Name="TruncateFPGradedModule" Label="for IsToricVariety, IsFpGradedLeftOrRightModulesObject, IsList, IsBool, IsFieldForHomalg"/>
 <Returns>a FreydCategoryObject
</Returns>
 <Description>
The arguments are a toric variety <Math>V</Math>, an f.p. graded module <Math>M</Math>, a list
<Math>d</Math> (specifying a element of the class group of <Math>V</Math>) a boolean <Math>B</Math> and a
field <Math>F</Math>. We then compute the truncation of <Math>M</Math> to the degree <Math>d</Math> and
return the corresponding vector space presentation as a FreydCategoryObject.
If <Math>B</Math> is true, we display additional information during the computation.
The latter may be useful for longer computations.
 </Description>
</ManSection>


<Example><![CDATA[
gap> P2 := ProjectiveSpace( 2 );
<A projective toric variety of dimension 2>
gap> cox_ring := CoxRing( P2 );
Q[x_1,x_2,x_3]
(weights: [ 1, 1, 1 ])
gap> source := GradedRow( [[[-1],1]], cox_ring );
<A graded row of rank 1>
gap> range := GradedRow( [[[0],1]], cox_ring );
<A graded row of rank 1>
gap> vars := IndeterminatesOfPolynomialRing( cox_ring );;
gap> matrix := HomalgMatrix( [[ vars[ 1 ] ]], cox_ring );
<A 1 x 1 matrix over a graded ring>
gap> obj1 := FreydCategoryObject(
>          GradedRowOrColumnMorphism( source, matrix, range ) );
<An object in Category of f.p. graded
left modules over Q[x_1,x_2,x_3]
(with weights [ 1, 1, 1 ])>
gap> IsWellDefined( obj1 );
true
gap> trunc_obj1 := TruncateFPGradedModule( P2, obj1, [ 2 ] );
<An object in Freyd( Category of matrices
over Q (with weights [ 1 ]) )>
gap> IsWellDefined( trunc_obj1 );
true
gap> Display( UnderlyingMatrix( RelationMorphism( trunc_obj1 ) ) );
1,0,0,0,0,0,
0,1,0,0,0,0,
0,0,0,1,0,0
(over a graded ring)
gap> trunc_obj2 := TruncateFPGradedModuleInParallel( P2, obj1, [ 2 ], 2 );
<An object in Freyd( Category of matrices
over Q (with weights [ 1 ]) )>
gap> IsWellDefined( trunc_obj2 );
true
gap> Display( UnderlyingMatrix( RelationMorphism( trunc_obj2 ) ) );
1,0,0,0,0,0,
0,1,0,0,0,0,
0,0,0,1,0,0
(over a graded ring)
]]></Example>


</Section>


<Section Label="Chapter_Truncations_of_fp_graded_modules_Section_Truncations_of_fp_graded_modules_in_parallel">
<Heading>Truncations of fp graded modules in parallel</Heading>

<ManSection>
  <Oper Arg="V, M, d, N, B. F" Name="TruncateFPGradedModuleInParallel" Label="for IsToricVariety, IsFpGradedLeftOrRightModulesObject, IsList, IsPosInt, IsBool, IsFieldForHomalg"/>
 <Returns>a FreydCategoryObject
</Returns>
 <Description>
The arguments are a toric variety <Math>V</Math>, an f.p. graded module <Math>M</Math>, a list
<Math>d</Math> (specifying a element of the class group of <Math>V</Math>), an integer <Math>N</Math>, a
boolean <Math>B</Math> and a field <Math>F</Math>. We then compute the truncation of <Math>M</Math> to
the degree <Math>d</Math> and return the corresponding vector space presentation
encoded as a FreydCategoryObject. This is performed in <Math>N</Math> child processes
in parallel. If <Math>B</Math> is true, we display additional information during the
computation. The latter may be useful for longer computations.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Truncations_of_fp_graded_modules_Section_Truncations_of_fp_graded_modules_morphisms">
<Heading>Truncations of fp graded modules morphisms</Heading>

<ManSection>
  <Oper Arg="V, M, d, B, F" Name="TruncateFPGradedModuleMorphism" Label="for IsToricVariety, IsFpGradedLeftOrRightModulesMorphism, IsList, IsBool, IsFieldForHomalg"/>
 <Returns>a FreydCategoryMorphism
</Returns>
 <Description>
The arguments are a toric variety <Math>V</Math>, an f.p. graded module morphism <Math>M</Math>,
a list <Math>d</Math> (specifying a element of the class group of <Math>V</Math>), a boolean <Math>B</Math> and
a field F. We then compute the truncation of <Math>M</Math> to the degree <Math>d</Math> and return
the corresponding morphism of vector space presentations encoded as a
FreydCategoryMorphism. If <Math>B</Math> is true, we display additional information
during the computation. The latter may be useful for longer computations.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Truncations_of_fp_graded_modules_Section_Truncations_of_fp_graded_modules_morphisms_in_parallel">
<Heading>Truncations of fp graded modules morphisms in parallel</Heading>

<ManSection>
  <Oper Arg="V, M, d, [ N1, N2, N3 ], B, F" Name="TruncateFPGradedModuleMorphismInParallel" Label="for IsToricVariety, IsFpGradedLeftOrRightModulesMorphism, IsList, IsList, IsBool, IsFieldForHomalg"/>
 <Returns>a FreydCategoryMorphism
</Returns>
 <Description>
The arguments are a toric variety <Math>V</Math>, an f.p. graded module morphism <Math>M</Math>,
a list <Math>d</Math> (specifying a element of the class group of <Math>V</Math>), a list of 3
non-negative integers [ <Math>N_1</Math>, <Math>N_2</Math>, <Math>N_3</Math> ], a boolean <Math>B</Math> and
a field F. We then compute the truncation of <Math>M</Math> to the degree <Math>d</Math> and return
the corresponding morphism of vector space presentations encoded as a
FreydCategoryMorphism. This is done in parallel: the truncation of the
source is done by <Math>N_1</Math> child processes in parallel, the truncation of the
morphism datum is done by <Math>N_2</Math> child processes and the truncation of the
range of <Math>M</Math> by <Math>N_3</Math> processes. If the boolean <Math>B</Math> is set to true,
we display additional information during the computation. The latter may
be useful for longer computations.
 </Description>
</ManSection>


</Section>



<Section Label="Chapter_Truncations_of_fp_graded_modules_Section_Truncations_of_fp_graded_module_morphisms">
<Heading>Truncations of f.p. graded module morphisms</Heading>

<Example><![CDATA[
gap> source := GradedRow( [[[-1],1]], cox_ring );
<A graded row of rank 1>
gap> range := GradedRow( [[[1],2]], cox_ring );
<A graded row of rank 2>
gap> matrix := HomalgMatrix( [[ vars[ 1 ] * vars[ 2 ],
>                            vars[ 1 ] * vars[ 3 ] ]], cox_ring );
<A 1 x 2 matrix over a graded ring>
gap> obj2 := FreydCategoryObject(
>          GradedRowOrColumnMorphism( source, matrix, range ) );
<An object in Category of f.p. graded
left modules over Q[x_1,x_2,x_3]
(with weights [ 1, 1, 1 ])>
gap> source := GradedRow( [[[0],1]], cox_ring );
<A graded row of rank 1>
gap> range := GradedRow( [[[1],2]], cox_ring );
<A graded row of rank 2>
gap> matrix := HomalgMatrix( [[ vars[ 2 ], vars[ 3 ] ]], cox_ring );
<A 1 x 2 matrix over a graded ring>
gap> mor := GradedRowOrColumnMorphism( source, matrix, range );
<A morphism in Category of graded rows
over Q[x_1,x_2,x_3] (with weights [ 1, 1, 1 ])>
gap> pres_mor := FreydCategoryMorphism( obj1, mor, obj2 );
<A morphism in Category of f.p. graded
left modules over Q[x_1,x_2,x_3]
(with weights [ 1, 1, 1 ])>
gap> IsWellDefined( pres_mor );
true
gap> trunc_pres_mor1 := TruncateFPGradedModuleMorphism( P2, pres_mor, [ 2 ] );
<A morphism in Freyd( Category of
matrices over Q (with weights [ 1 ]) )>
gap> IsWellDefined( trunc_pres_mor1 );
true
gap> trunc_pres_mor2 := TruncateFPGradedModuleMorphismInParallel
>                             ( P2, pres_mor, [ 2 ], [ 2, 2, 2 ] );
<A morphism in Freyd( Category of
matrices over Q (with weights [ 1 ]))>
gap> IsWellDefined( trunc_pres_mor2 );
true
]]></Example>


</Section>


</Chapter>

