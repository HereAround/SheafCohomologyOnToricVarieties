<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Tools_for_FPGradedModules">
<Heading>Tools for FPGradedModules</Heading>

<Section Label="Chapter_Tools_for_FPGradedModules_Section_Minimal_free_resolutions">
<Heading>Minimal free resolutions</Heading>

<ManSection>
  <Oper Arg="L, R" Name="LeftIdealForCAP" Label="for IsList, IsHomalgGradedRing"/>
 <Returns>a f.p. module presentation
</Returns>
 <Description>
The argument is a list L of generators of an ideal and a homalg graded ring R.
This method then construct the left ideal in this ring generated by these generators.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="L, R" Name="RightIdealForCAP" Label="for IsList, IsHomalgGradedRing"/>
 <Returns>a f.p. module presentation
</Returns>
 <Description>
The argument is a list L of generators of an ideal and a homalg graded ring R.
This method then construct the right ideal in this ring generated by these generators.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="M" Name="MinimalFreeResolutionForCAP" Label="for IsFpGradedLeftOrRightModulesObject"/>
 <Returns>a complex of projective graded module morphisms
</Returns>
 <Description>
The argument is a graded left or right module presentation <A>M</A>.
We then compute a minimal free resolution of <A>M</A>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Tools_for_FPGradedModules_Section_Betti_tables">
<Heading>Betti tables</Heading>

<ManSection>
  <Attr Arg="M" Name="BettiTableForCAP" Label="for IsFpGradedLeftOrRightModulesObject"/>
 <Returns>a list of lists
</Returns>
 <Description>
The argument is a graded left or right module presentation <A>M</A>.
We then compute the Betti table of <A>M</A>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Tools_for_FPGradedModules_Section_Example_Minimal_free_resolution_and_Betti_table">
<Heading>Example: Minimal free resolution and Betti table</Heading>

<Example><![CDATA[
gap> P2 := ProjectiveSpace( 2 );
<A projective toric variety of dimension 2>
gap> IR := IrrelevantLeftIdealForCAP( P2 );;
gap> IsWellDefined( IR );
true
gap> resolution := MinimalFreeResolutionForCAP( IR );
<An object in Complex category of Category of graded
rows over Q[x_1,x_2,x_3] (with weights [ 1, 1, 1 ])>
gap> differential_function :=
>                     UnderlyingZFunctorCell( resolution )!.differential_func;
function( i ) ... end
gap> IsWellDefined( differential_function( -1 ) );
true
gap> IsWellDefined( differential_function( -2 ) );
true
gap> IsWellDefined( differential_function( -3 ) );
true
gap> BT := BettiTableForCAP( IR );
[ [ -1, -1, -1 ], [ -2, -2, -2 ], [ -3 ] ]
]]></Example>


</Section>


</Chapter>

