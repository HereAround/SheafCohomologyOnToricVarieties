#############################################################################
##
##  CohomologyViaGSForGradedModules.gi         ToricVarieties package
##
##  Copyright 2015- 2016, Sebastian Gutsche, TU Kaiserslautern
##                        Martin Bies,       ITP Heidelberg
##
##  Sheaf cohomology via the theorem of Greg. Smith
##
#############################################################################



###############################################################################
##
#! @Section Implementation of the theorem of G. Smith for GradedModules package
##
###############################################################################

# extract the weights a_ij for a f.p. Z^n-graded S-module
InstallMethod( MultiGradedBettiTable,
               " for f.p. graded S-modules.",
               [ IsGradedModuleOrGradedSubmoduleRep ],
  function( F )
    local resolution, morphismsOfResolution, i, j, a, buffer;

    # compute minimal free resolution/resolution
    resolution := Resolution( F );
    morphismsOfResolution := MorphismsOfComplex( resolution );

    # investigate these morphisms to compute the degrees a
    a := [];
    for i in [ 1.. Length( morphismsOfResolution ) ] do
      Add( a, DegreesOfGenerators( Range( morphismsOfResolution[ i ] ) ) );
    od;

    # if the last object in the resolution is non-zero, then its degrees of generators need to be added
    if not IsZero( morphismsOfResolution[ Length( morphismsOfResolution ) ] ) then
      Add( a, DegreesOfGenerators( Source( morphismsOfResolution[ i ] ) ) );
    fi;

    # represent the degrees a as lists of ring elements
    for i in [ 1.. Length( a ) ] do
      buffer := [];
      for j in [ 1.. Length( a[ i ] ) ] do
	Add( buffer, UnderlyingListOfRingElements( a[ i ][ j ] ) ); 
      od;
      a[ i ] := buffer;
    od;

    # return the weights
    return a;

end );

# this methods checks if the conditions in the theorem by Greg Smith are satisfied
BindGlobal( "TORIC_VARIETIES_INTERNAL_GS_PARAMETER_CHECK",
  function( variety, e, module, u, Index, aM )
    local B, BPower, aB, aB01, d, i, j, C, deg, div, result;

    # check if Index is meaningful
    if Index < 0 then
    
      Error( "Index must be non-negative." );
      return false;
      
    elif Index > Dimension( variety ) then
    
      Error( "Index must not be greater than the dimension of the variety." );
      return false;

    fi;

    # we compute the e-th Frobenius power of the degree u layer (considered as S-module)
    B := GradedLeftSubmodule( DegreeXLayer( variety, u ) , CoxRing( variety ) );
    BPower := GradedLeftSubmodule( List( EntriesOfHomalgMatrix( MatrixOfSubobjectGenerators( B ) ), x -> x^(e) ) );

    # compute the respective degree that is needed to compare
    aB := MultiGradedBettiTable( BPower );
    aB01 := aB[ 1 ][ 1 ];

    # determine range in which we need to check
    d := Minimum( Dimension( variety ) - Index, Length( aM ) -1 );

    # compute the improved vanishing set
    C := ImprovedVanishingSetForGS( variety );

    # now check the GS-criterion
    for i in [ 0..d ] do
      for j in [ 1..Length( aM[ i+1 ] ) ] do

        # check if aB01 - aM[ i+1 ][ j ] is contained in the GS cone
        if not PointContainedInVanishingSet( C, aB01 - aM[ i+1 ][ j ] ) then
          return false;
        fi;

      od;
    od;

    # if nothing unusual was found, the criterion is satisfied and we return 'true'
    return true;

end );

# compute H^0 by applying the theorem from Greg Smith
InstallMethod( H0ByGS,
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep, IsBool ],
  function( variety, module, saturation_wished )
    local deg, B, iota, mSat, aM, e, BPower, zero, GH;

    # check that the input is valid to work with
    if not IsSmooth( variety ) then
        
      Error( "Variety must be smooth." );
      return false;

    elif not IsProjective( variety ) then

      Error( "Variety must be projective. Note that this implies completness." );
      return false;
      
    fi;

    # compute smallest ample divisor via Nef cone
    deg := ClassOfSmallestAmpleDivisor( variety );

    # and the corresponding ideal in the Coxring that is generated by this degree layer
    B := GradedLeftSubmodule( DegreeXLayer( variety, deg ) , CoxRing( variety ) );
    iota := EmbeddingInSuperObject( B );
    SetIsMorphism( iota, true );
    
    # next saturate 'module' with respect to B if the user wishes to
    if saturation_wished then
      mSat := GradedHom( CoxRing( variety ), GradedHom( B, module ) );
      while not IsIsomorphism( GradedHom( iota, mSat ) ) do
    
        mSat := GradedHom( CoxRing( variety ), GradedHom( B, mSat ) );
   
      od;
    else
      mSat := module;
    fi;
    
    # now compute the Betti-table of mSat
    aM := MultiGradedBettiTable( mSat );
    
    # determine integer e that we need to perform the computation of the cohomology
    e := 0;
    while not TORIC_VARIETIES_INTERNAL_GS_PARAMETER_CHECK( variety, e, mSat, deg, 0, aM ) do
      e := e + 1;
    od;

    # inform the user that we have found a suitable e
    Print( Concatenation( "Found integer: ", String( e ) , "\n" ) );
            
    # compute the appropriate Frobenius power of the ideal B
    BPower := GradedLeftSubmodule( List( EntriesOfHomalgMatrix( MatrixOfSubobjectGenerators( B ) ), x -> x^(e) ) );    

    # compute the GradedHom
    GH := ByASmallerPresentation( GradedHom( BPower, mSat ) );

    # truncate the degree 0 part
    zero := List( [ 1..Rank( ClassGroup( variety ) ) ], x -> 0 );
    return [ e, DegreeXLayerOfFPGradedModuleForGradedModules( variety, GH, zero ) ];
   
end );

InstallMethod( H0ByGS, 
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep ],
  function( variety, module )

    return H0ByGS( variety, module, false );

end );

# compute H^0 by applying the theorem from Greg Smith
InstallMethod( H0EstimateByGS,
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep, IsBool ],
  function( variety, module, saturation_wished )
    local deg, B, iota, mSat, aM, e, BPower, zero, GH, gens_module, vec_space;

    # check that the input is valid to work with
    if not IsSmooth( variety ) then
        
      Error( "Variety must be smooth." );
      return false;

    elif not IsProjective( variety ) then

      Error( "Variety must be projective. Note that this implies completness." );
      return false;
      
    fi;

    # compute smallest ample divisor via Nef cone
    deg := ClassOfSmallestAmpleDivisor( variety );

    # and the corresponding ideal in the Coxring that is generated by this degree layer
    B := GradedLeftSubmodule( DegreeXLayer( variety, deg ) , CoxRing( variety ) );
    iota := EmbeddingInSuperObject( B );
    SetIsMorphism( iota, true );
    
    # next saturate 'module' with respect to B if the user wishes to
    if saturation_wished then
      mSat := GradedHom( CoxRing( variety ), GradedHom( B, module ) );
      while not IsIsomorphism( GradedHom( iota, mSat ) ) do
    
        mSat := GradedHom( CoxRing( variety ), GradedHom( B, mSat ) );
   
      od;
    else
      mSat := module;
    fi;
    
    # now compute the Betti-table of mSat
    aM := MultiGradedBettiTable( mSat );
    
    # determine integer e that we need to perform the computation of the cohomology
    e := 0;
    while not TORIC_VARIETIES_INTERNAL_GS_PARAMETER_CHECK( variety, e, mSat, deg, 0, aM ) do
      e := e + 1;
    od;

    # inform the user that we have found a suitable e
    Print( Concatenation( "Found integer: ", String( e ) , "\n" ) );
            
    # compute the appropriate Frobenius power of the ideal B
    BPower := GradedLeftSubmodule( List( EntriesOfHomalgMatrix( MatrixOfSubobjectGenerators( B ) ), x -> x^(e) ) );    

    # compute the GradedHom
    GH := GradedHom( BPower, mSat );

    # from the module of generators of GH
    gens_module := FreeLeftModuleWithDegrees( DegreesOfGenerators( GH ), CoxRing( variety ) );
    
    # and truncate this module to degree 0
    zero := List( [ 1..Rank( ClassGroup( variety ) ) ], x -> 0 );
    vec_space := DegreeXLayerOfFPGradedModuleForGradedModules( variety, GH, zero );
    
    # now check if the estimate is even precise
    if Dimension( vec_space ) = 0 then

      Print( "Found precise result: H^0 = 0 \n" );
      return [ e, vec_space ];

    else

      Print( "Found estimate of H^0 as follows: \n" );
      Print( Concatenation( "0 <= H0 <= ", String( Dimension( vec_space ) ), "\n" ) );
      return [ e, vec_space, GH ];

    fi;

end );

InstallMethod( H0EstimateByGS,
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep ],
  function( variety, module )

    return H0EstimateByGS( variety, module, false );

end );

# compute H^i by applying the theorem from Greg Smith
InstallMethod( HiByGS,
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep, IsInt, IsBool ],
  function( variety, module, index, saturation_wished )
    local deg, B, iota, mSat, aM, e, BPower, zero, GE;

    # check that the input is valid to work with
    if not IsSmooth( variety ) then
        
      Error( "Variety must be smooth." );
      return false;

    elif not IsProjective( variety ) then

      Error( "Variety must be projective. Note that this implies completness." );
      return false;
      
    elif index < 0 then
    
      Error( "Index must be non-negative." );
      return false;
      
    elif index > Dimension( variety ) then
    
      Error( "Index must not be greater than the dimension of the variety." );
      return false;
      
    fi;

    # compute smallest ample divisor via Nef cone
    deg := ClassOfSmallestAmpleDivisor( variety );

    # and the corresponding ideal in the Coxring that is generated by this degree layer
    B := GradedLeftSubmodule( DegreeXLayer( variety, deg ) , CoxRing( variety ) );
    iota := EmbeddingInSuperObject( B );
    SetIsMorphism( iota, true );
    
    # next saturate 'module' with respect to B if the user wishes to
    if saturation_wished then
      mSat := GradedHom( CoxRing( variety ), GradedHom( B, module ) );
      while not IsIsomorphism( GradedHom( iota, mSat ) ) do
    
        mSat := GradedHom( CoxRing( variety ), GradedHom( B, mSat ) );
    
      od;

    else
      mSat := module;
    fi;
    
    # now compute the Betti-table of mSat
    aM := MultiGradedBettiTable( mSat );
    
    # determine integer e that we need to perform the computation of the cohomology
    e := 0;
    while not TORIC_VARIETIES_INTERNAL_GS_PARAMETER_CHECK( variety, e, mSat, deg, index, aM ) do
      e := e + 1;
    od;

    # inform the user that we have found a suitable e
    Print( Concatenation( "Found integer: ", String( e ) , "\n" ) );

    # now compute the appropriate Frobenius power of the degree 'deg' part (considered as S-module)
    BPower := GradedLeftSubmodule( List( EntriesOfHomalgMatrix( MatrixOfSubobjectGenerators( B ) ), x -> x^(e) ) );    

    # compute the GradedHom
    GE := ByASmallerPresentation( GradedExt( index, BPower, mSat ) );

    # truncate the degree 0 part
    zero := List( [ 1..Rank( ClassGroup( variety ) ) ], x -> 0 );
    return [ e, DegreeXLayerOfFPGradedModuleForGradedModules( variety, GE, zero ) ];

end );

# compute H^i by applying the theorem from Greg Smith
InstallMethod( HiByGS, 
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep, IsInt ],
  function( variety, module, index )

    return HiByGS( variety, module, index, false );

end );

# compute all cohomology classes by applying the theorem from Greg Smith
InstallMethod( AllCohomologiesByGS, 
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep, IsBool ],
  function( variety, module, saturation_wished )
    local deg, B, iota, mSat, aM, e, BPower, cohoms, zero, i, GE, cohom;

    # check that the input is valid to work with
    if not IsSmooth( variety ) then

      Error( "Variety must be smooth." );
      return false;

    elif not IsProjective( variety ) then

      Error( "Variety must be projective. Note that this implies completness." );
      return false;

    fi;

    # compute smallest ample divisor via Nef cone
    deg := ClassOfSmallestAmpleDivisor( variety );

    # and the corresponding ideal in the Coxring that is generated by this degree layer
    B := GradedLeftSubmodule( DegreeXLayer( variety, deg ) , CoxRing( variety ) );
    iota := EmbeddingInSuperObject( B );
    SetIsMorphism( iota, true );

    # next saturate 'module' with respect to B if wished
    if saturation_wished then
      mSat := GradedHom( CoxRing( variety ), GradedHom( B, module ) );
      while not IsIsomorphism( GradedHom( iota, mSat ) ) do
        mSat := GradedHom( CoxRing( variety ), GradedHom( B, mSat ) );
      od;
    else
      mSat := module;
    fi;

    # now compute the Betti-table of mSat
    aM := MultiGradedBettiTable( mSat );

    # determine integer e that we need to perform the computation of the cohomology
    e := 0;
    while not TORIC_VARIETIES_INTERNAL_GS_PARAMETER_CHECK( variety, e, mSat, deg, 0, aM ) do
      e := e + 1;
    od;

    # inform the user that we have found a suitable e
    Print( Concatenation( "Found integer: ", String( e ) , "\n" ) );
            
    # now compute the appropriate Frobenius power of the degree 'deg' part (considered as S-module)
    BPower := GradedLeftSubmodule( List( EntriesOfHomalgMatrix( MatrixOfSubobjectGenerators( B ) ), x -> x^(e) ) );    

    # initialise the list of the cohomology classes and compute the individual vector spaces
    cohoms := [];
    zero := List( [ 1..Rank( ClassGroup( variety ) ) ], x -> 0 );
    for i in [ 0..Dimension( variety ) ] do

      # compute the module that we need to truncate    
      GE := ByASmallerPresentation( GradedExt( i, BPower, mSat ) );

      # truncate the degree 0 part
      cohom := DegreeXLayerOfFPGradedModuleForGradedModules( variety, GE, zero );
      Add( cohoms, [ i, cohom ] );

      # inform the user that we computed another cohomology class
      Print( Concatenation( "Computation finished for i=", String( i ) , "\n" ) );
      Display( cohom );
      Print( "...\n" );

    od;

    # return the result
    return [e, cohoms];

end );

# compute all cohomology classes by applying the theorem from Greg Smith
InstallMethod( AllCohomologiesByGS, 
               " for a toric variety, a f.p. graded S-module ",
               [ IsToricVariety, IsGradedModuleOrGradedSubmoduleRep ],
  function( variety, module )

    return AllCohomologiesByGS( variety, module, false );

end );